<!doctype html><html lang=en><head><title>The Big Learning Set for Big World Helpers :: Simone Sturniolo's Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="On November 12, 2012, Randall Munroe&rsquo;s famous xkcd comic published Up Goer Five, a blueprint and explanation of the Apollo V rocket written using only the 1000 most common words of the English language (as he estimated them). Later on, on November 24, 2015, came out Thing Explainer, an entire illustrated book of similar explanations for other objects and concepts. The &ldquo;only the most common 1000 words&rdquo; style of writing sounds sometimes stilted, sometimes a bit funny, but these texts certainly prove that it&rsquo;s enough to talk virtually about anything.
In the age of LLMs, would it be possible to have a training set built only on the most common 1000 words of the English language?
Let&rsquo;s try.
"><meta name=keywords content="blog,tech,programming,science,data science,machine learning,math,physics,curiosity"><meta name=robots content="noodp"><link rel=canonical href=https://stur86.github.io/s-plus-plus/posts/the-big-learning-set-for-big-world-helpers/><link rel=stylesheet href=https://stur86.github.io/s-plus-plus/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css><link rel=stylesheet href=https://stur86.github.io/s-plus-plus/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css><link rel=stylesheet href=https://stur86.github.io/s-plus-plus/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css><link rel=stylesheet href=https://stur86.github.io/s-plus-plus/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css><link rel=stylesheet href=https://stur86.github.io/s-plus-plus/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css><link rel=stylesheet href=https://stur86.github.io/s-plus-plus/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css><link rel=stylesheet href=https://stur86.github.io/s-plus-plus/css/main.min.36833afd348409fc6c3d09d0897c5833d9d5bf1ff31f5e60ea3ee42ce2b1268c.css><link rel=stylesheet href=https://stur86.github.io/s-plus-plus/css/menu.min.3c17467ebeb3d38663dce68f71f519901124fa5cbb4519b2fb0667a21e9aca39.css><link rel=stylesheet href=https://stur86.github.io/s-plus-plus/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css><link rel=stylesheet href=https://stur86.github.io/s-plus-plus/css/post.min.e6dddd258e64c83e05cec0cd49c05216742d42fc8ecbfbe6b67083412b609bd3.css><link rel=stylesheet href=https://stur86.github.io/s-plus-plus/css/syntax.min.a0773cce9310cb6d8ed23e50f005448facf29a53001b57e038828daa466b25c0.css><link rel=stylesheet href=https://stur86.github.io/s-plus-plus/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css><link rel=stylesheet href=https://stur86.github.io/s-plus-plus/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css><link rel=stylesheet href=https://stur86.github.io/s-plus-plus/terminal.css><link rel="shortcut icon" href=https://stur86.github.io/s-plus-plus/favicon.png><link rel=apple-touch-icon href=https://stur86.github.io/s-plus-plus/apple-touch-icon.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="The Big Learning Set for Big World Helpers"><meta property="og:description" content="On November 12, 2012, Randall Munroe&rsquo;s famous xkcd comic published Up Goer Five, a blueprint and explanation of the Apollo V rocket written using only the 1000 most common words of the English language (as he estimated them). Later on, on November 24, 2015, came out Thing Explainer, an entire illustrated book of similar explanations for other objects and concepts. The &ldquo;only the most common 1000 words&rdquo; style of writing sounds sometimes stilted, sometimes a bit funny, but these texts certainly prove that it&rsquo;s enough to talk virtually about anything.
In the age of LLMs, would it be possible to have a training set built only on the most common 1000 words of the English language?
Let&rsquo;s try.
"><meta property="og:url" content="https://stur86.github.io/s-plus-plus/posts/the-big-learning-set-for-big-world-helpers/"><meta property="og:site_name" content="Simone Sturniolo's Blog"><meta property="og:image" content="https://stur86.github.io/s-plus-plus/og-image.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:section" content="Blog"><meta property="article:published_time" content="2025-12-04 07:23:00 +0000 UTC"><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}}</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.13.1/font/bootstrap-icons.min.css><link rel=stylesheet href=/s-plus-plus/css/custom-icons.css><link rel=stylesheet href=/s-plus-plus/css/code-styles.css></head><body><div class="container center"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>S++</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/s-plus-plus/>Home</a></li><li><a href=/s-plus-plus/posts>Posts</a></li><li><a href=/s-plus-plus/projects>Projects</a></li><li><a href=/s-plus-plus/about>About</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/s-plus-plus/>Home</a></li><li><a href=/s-plus-plus/posts>Posts</a></li><li><a href=/s-plus-plus/projects>Projects</a></li><li><a href=/s-plus-plus/about>About</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=https://stur86.github.io/s-plus-plus/posts/the-big-learning-set-for-big-world-helpers/>The Big Learning Set for Big World Helpers</a></h1><div class=post-meta><time class=post-date>2025-12-04</time><span class=post-author>Simone Sturniolo</span><span class=post-reading-time>16 min read (3321 words)</span></div><span class=post-tags>#<a href=https://stur86.github.io/s-plus-plus/tags/machine-learning/>Machine Learning</a>&nbsp;
#<a href=https://stur86.github.io/s-plus-plus/tags/data/>Data</a>&nbsp;
#<a href=https://stur86.github.io/s-plus-plus/tags/ai/>AI</a>&nbsp;
#<a href=https://stur86.github.io/s-plus-plus/tags/llm/>LLM</a>&nbsp;</span><div class=post-content><div><p>On November 12, 2012, Randall Munroe&rsquo;s famous xkcd comic published <a href=https://xkcd.com/1133/>Up Goer Five</a>, a blueprint and explanation of the Apollo V rocket written using only the 1000 most common words of the English language (as he estimated them). Later on, on November 24, 2015, came out <a href=https://xkcd.com/thing-explainer/>Thing Explainer</a>, an entire illustrated book of similar explanations for other objects and concepts. The &ldquo;only the most common 1000 words&rdquo; style of writing sounds sometimes stilted, sometimes a bit funny, but these texts certainly prove that it&rsquo;s <em>enough</em> to talk virtually about anything.</p><p>In the age of LLMs, would it be possible to have a training set built only on the most common 1000 words of the English language?</p><p>Let&rsquo;s try.</p><h2 id=why>Why?<a href=#why class=hanchor arialabel=Anchor>#</a></h2><p>In short: because a simple training set would be an interesting Petri dish for training simple (and small!) language models.</p><p>This has already been tried. In 2023 two researchers affiliated with Microsoft published <a href=https://arxiv.org/abs/2305.07759>TinyStories</a> (HuggingFace repository <a href=https://huggingface.co/datasets/roneneldan/TinyStories>here</a>), a project in which they first developed a large synthetic training set of simple child-like stories with GPT-3.5 and GPT-4, then trained small transformers on it. And I do mean <em>small</em>; the smallest TinyStories model has merely 1M parameters, the largest has 33M. By comparison most modern state-of-the-art LLMs will have hundreds of billions if not trillions of parameters. Yet these models speak quite coherent English - the 1M model maybe struggles a bit occasionally, but the others are fine. However they&rsquo;re only able to produce text that reads like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>One day, Lily and her family went to the park. Lily saw a big slide and ran towards it. She wanted to go down the slide with her friends. But her mom said, &#34;No, Lily. You have to stay with us.&#34;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Lily was sad, but she listened to her mom. Later that day, Lily and her family went to the beach. Lily saw a boy who had no toys. She wanted to play with him, but she remembered what her mom said. She decided to share her toys with the boy.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>The boy was happy and said, &#34;Thank you, Lily!&#34; Lily smiled and felt happy too. She learned that it&#39;s important to share and be kind to others. From that day on, Lily always shared her toys with her friends.
</span></span></code></pre></div><p>(this is a story I just generated on the fly with TinyStories-33M and the HuggingFace Transformers library).</p><p>This dataset doesn&rsquo;t stick to a specific subset of English, that I know of, though it&rsquo;s clear that it also tends to have a limited vocabulary. The xkcd &ldquo;1000 words&rdquo; approach makes me curious because it allows a very explicit dictionary, which has a very direct effect on reducing the amount of weights the model needs (less embeddings, for starters), as well as making real the possibility of using <em>words</em> instead of <em>tokens</em> as the units of language (which yes, means sacrificing flexibility, but for an experiment that can be acceptable, and should make it easier). And its ability to talk about anything, to be something like a &ldquo;Turing complete&rdquo; subset of English language, so to speak, is essentially already proven. There are other alternative similar subsets with like properties, such as Charles Kay Ogden&rsquo;s 1925 <a href=https://en.wikipedia.org/wiki/Basic_English>Basic English</a>, which only uses 850 words. But xkcd&rsquo;s model benefits from modernity (for example it includes the word &ldquo;computer&rdquo;) and feels somewhat more expressive to me.</p><p>So my goal started as: generate a synthetic dataset using entirely the &ldquo;Up-Goer Five&rdquo; vocabulary and style, and eventually try training some models on it. I don&rsquo;t really expect to be able to easily get to &ldquo;proper&rdquo; dataset sizes (even for small models, hundreds of millions or billions of tokens/words would be usual) due to limits in compute budget but at least I can have a proof of concept and a small starting point.</p><h2 id=the-rules>The rules<a href=#the-rules class=hanchor arialabel=Anchor>#</a></h2><p>First things first: Randall Munroe is a <em>cheat</em>.</p><p>(hey, I&rsquo;m just playing Randall, you know I love ya)</p><p>Ok, now to be a bit more specific and less inflammatory. The original xkcd comic mentions the 1000 most common English words. I used <a href=https://github.com/ChristopherA/iambic-mnemonic/tree/master>this repository</a> as my source for the list (check it out, it&rsquo;s got a lot of other useful word lists). I assume it was scraped from the xkcd <a href=https://xkcd.com/simplewriter/>Simple Writer</a> and it appears identical for example <a href=https://splasho.com/upgoer5/>in this fanmade editor</a> (credit to Theo Sanderson). However the list is by no means complete. It goes without saying for example that if a noun is acceptable, so is its plural, and that won&rsquo;t have to be included in the list&mldr; except for &ldquo;child&rdquo; and &ldquo;children&rdquo;, which both appear, possibly because the latter is an exception to the rule of simply appending an -s suffix. But if you try in Simple Writer, &ldquo;babies&rdquo; is also accepted, despite being a non-straightforward plural, and only &ldquo;baby&rdquo; appearing in the list. And yet &ldquo;asses&rdquo; (<em>snicker</em>) is not accepted, despite &ldquo;ass&rdquo; (<em>snicker</em>) being. So the rule is rather inconsistent. Similar issues appear with verb and adjective inflections.</p><p>But it doesn&rsquo;t stop there; in the original title of the original comic we already have an even more confusing violation. &ldquo;Up-Goer Five&rdquo; includes the word &ldquo;goer&rdquo;, and that&rsquo;s <em>not</em> an accepted inflection of the verb &ldquo;go&rdquo;; it&rsquo;s an <em>action noun</em>, something that some verbs do allow (&ldquo;play&rdquo; => &ldquo;player&rdquo;, &ldquo;hunt&rdquo; => &ldquo;hunter&rdquo;) but not a proper conjugation. And while more verbose, the word set absolutely allows circumlocutions like &ldquo;thing that goes&rdquo;, which makes action nouns pure syntactic sugar.</p><p>I didn&rsquo;t particularly care about sticking precisely to the original Simple Writer&rsquo;s standards as much as I did about having a consistent set of rules and words allowed. Therefore I ended up deciding for my own &ldquo;house rules&rdquo;. I used the library <a href=https://github.com/bjascob/LemmInflect><code>lemminflect</code></a> for quick and dirty Part-of-Speech tagging. Essentially for any base word I allowed the following tags (I&rsquo;m using the Penn Treebank Tagset convention here which is also what <code>lemminflect</code> uses):</p><ul><li><strong>NNS</strong>: noun plural (e.g. &ldquo;house&rdquo; => &ldquo;houses&rdquo;)</li><li><strong>VBZ</strong>: verb, third person singular present (e.g. &ldquo;go&rdquo; => &ldquo;goes&rdquo;)</li><li><strong>VBD</strong>: verb, past tense (e.g. &ldquo;go&rdquo; => &ldquo;went&rdquo;)</li><li><strong>VBG</strong>: verb, gerund or present participle (e.g. &ldquo;go&rdquo; => &ldquo;going&rdquo;)</li><li><strong>VBN</strong>: verb, past participle (e.g. &ldquo;go&rdquo; => &ldquo;gone&rdquo;)</li><li><strong>JJR</strong>: adjective, comparative (e.g. &ldquo;strong&rdquo; => &ldquo;stronger&rdquo;)</li><li><strong>JJS</strong>: adjective, superlative (e.g. &ldquo;strong&rdquo; => &ldquo;strongest&rdquo;)</li><li><strong>RBR</strong>: adverb, comparative (e.g. &ldquo;soon&rdquo; => &ldquo;sooner&rdquo;)</li><li><strong>RBS</strong>: adverb, superlative (e.g. &ldquo;soon&rdquo; => &ldquo;soonest&rdquo;)</li></ul><p>In addition to this, I defined and allowed a new non-standard category, <strong>ANN</strong> for action nouns. This is not supported by <code>lemminflect</code> and I simply allowed only on select verbs for now, which is kind of arbitrary I realise but felt the best compromise between allowing for some of that &ldquo;syntactic sugar&rdquo; I mentioned and preventing the total number of words from ballooning too much. Wherever inflected forms were already present in the original 1000 words they weren&rsquo;t double counted (so &ldquo;children&rdquo; became simply the NNS form of &ldquo;child&rdquo;). This makes for a total of 2917 words allowed, including various contracted forms with apostrophes (like &ldquo;you&rsquo;ll&rdquo; or &ldquo;he&rsquo;s&rdquo;) which appeared as words in the original list and I allowed to stay as such (though technically I guess they could be removed and replaced by their non-contracted forms - more syntactic sugar I guess). My hope is also that in some future projects I might bring the number back to almost 1000; something I&rsquo;d like to experiment with is &ldquo;modifier tokens&rdquo; that inflect the word that follows them. So instead of <code>went</code> for example you could have <code>&lt;VBD>go</code>, which reduces drastically the number of tokens required to describe a text to only base forms, modifiers, and punctuation. This obviously also limits the things the model can do (no languages other than English, no code, no made up words or names, not even a bit of flexibility to typos) but again, for a very limited experiment, it&rsquo;s not particularly important.</p><p>On to generation.</p><h2 id=generation>Generation<a href=#generation class=hanchor arialabel=Anchor>#</a></h2><p><a href=https://github.com/stur86/tinyfacts-gen><i class="bi bi-github"></i>
Here is the repository with the code for this part</a>.</p><p>I created a few basic scripts to help me with the work. After generating the allowed word forms with <code>lemminflect</code>, I stored them in a JSON file and made some utility classes to read and use them. The main commands provided are:</p><ul><li><code>check</code>: allows for checking a given generated file and highlight any disallowed words;</li><li><code>editor</code>: launches a terminal text editor that checks live what you type in and thus allows human-generated content (I made a couple of these mostly as examples for the agents);</li><li><code>agent</code>: launches an AI agent which allows you to request generations on a certain topic;</li><li><code>stats</code>: prints statistics on all current generated files.</li></ul><h3 id=the-editor>The editor<a href=#the-editor class=hanchor arialabel=Anchor>#</a></h3><p>This was created with <a href=https://textual.textualize.io/>Textual</a>, which is a pretty neat library for quick Python terminal GUIs. I had AI customize a bit the text editor itself to allow for highlighting the way I wanted it, and it works perfectly well for quick editing or creation of new entries. It&rsquo;s not a <em>fast</em> way of creating content but it is a useful tool, especially as human-generated content provides a good starting example.</p><h3 id=the-agent>The agent<a href=#the-agent class=hanchor arialabel=Anchor>#</a></h3><p>For this I used <a href=https://ai.pydantic.dev/>Pydantic AI</a>, which personally I find amazing. The official website states:</p><blockquote><p>We built Pydantic AI with one simple aim: to bring that FastAPI feeling to GenAI app and agent development.</p></blockquote><p>and I agree, it definitely conveys that feel - it&rsquo;s very simple and straightforward to make an agent with it. In this case, it wasn&rsquo;t a particularly hard task either. All I did was provide the agent with a single tool, a checker which allows it to identify the disallowed words in its proposed text and a bit of context around them. In my experience even smart models have a very hard time one-shot producing compliant text, but with a checker it&rsquo;s a different story, and they can simply iterate to converge to a good answer.</p><p>Pydantic AI allows also connecting to a local Ollama server and I did make use of that, albeit mostly for testing purposes. The best tool-enabled models I could find that I can run fully on my laptop are <code>llama3.1:8b</code> and <code>qwen3:8b</code>, but they still struggle - especially because increasing the context length to what&rsquo;s needed for this task (the prompt alone is over 7000 tokens) makes them slow and expensive to run.</p><h2 id=results>Results<a href=#results class=hanchor arialabel=Anchor>#</a></h2><p>So what does this end up looking like?</p><p>For smart, powerful frontier models, quite good. Some files I had generated by Claude 4.5 Sonnet via the agent interface in VSCode, simply giving it access to the command line tool to check for mistakes and iterate. It did well, and enthusiastically kept creating new files until I stopped it. Here&rsquo;s its rendition of the plot of The Lord of the Rings, aka, &ldquo;the ring story&rdquo;:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>There is a small round thing that can make the person who wears it disappear. But this round thing is very bad. It makes people want to keep it and never let anyone else have it. The longer someone has it, the more it changes them into something bad.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>A small person who lives in a space under the ground finds the round thing. He keeps it for many years and it makes him live much longer than he should. But it also makes him sad and alone. One day he loses the round thing and another small person finds it.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>The new small person does not know what the round thing can do at first. An old man who knows many things tells him that the round thing must be broken or bad things will happen to everyone. The only way to break it is to drop it into the fire where it was first made, far away.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>The small person and his friends go on a long walk to get to the fire. Many bad things try to stop them. There are big animals that want to kill them. There are bad people who want to take the round thing for themselves. The small person has to be very strong to keep going.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>The round thing keeps trying to make the small person want to keep it. It talks to him in his head. It makes him not trust his friends. It makes him tired and sad. But the small person keeps going because he knows he has to break the round thing.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>When the small person finally gets to the fire, the round thing has made him change his mind. He does not want to drop it in. But his friend from before comes back and they fight. The friend falls into the fire with the round thing and they both burn.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>After the round thing is gone, all the bad things that it made happen start to go away. The bad people lose their power. The small person and his friends can go home. They are all very tired but happy that they saved everyone.
</span></span></code></pre></div><p>(not sure if the first &ldquo;small person&rdquo; here is meant to be Bilbo, or if it&rsquo;s meant to be Smeagol/Gollum, and Bilbo and Frodo were conflated into one; I suspect the latter given the description of the ending)</p><p>I then used the agent with GPT-5.1. The results are, again, pretty good! The title of this blog post comes from GPT-5.1&rsquo;s own way to refer to large language models:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>A big word helper is a kind of computer brain that works with words.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>It reads a very, very big number of word lines from books, talks, stories, and many other written things. From these, it learns how people usually put words together. It does not remember one person words as that person. Instead, it looks at all the words as one huge crowd and learns usual ways in how words follow each other.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[...]
</span></span></code></pre></div><p>and training sets:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>When people build thinking computers, they need to show them many, many pieces of something they care about. A “big learning set” is the big group of those pieces.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Think of a big learning set like a huge table. Each line in the table is one thing you want the computer to learn about. This one line is one piece. All the lines together are the set.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Each line has several parts. A part is one kind of fact about the thing. For a picture of a cat, one part could say “this is a cat.” Another part could hold numbers that tell how the picture looks. For a house, parts could say how big it is, how old it is, and how much money it takes to buy it.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[...]
</span></span></code></pre></div><p>These explanation are honestly excellent. They use interesting and appropriate turns of phrase to refer to things, they say a lot, and they flow naturally and smoothly despite the constraints. They also very rarely ever use disallowed words. It usually takes GPT-5.1 something like 20k to 30k tokens total to produce one answer, with 3-4 calls to the word checker tool. Only once I had to manually fix an answer by changing a single word.</p><p>By comparison, here is GPT-5-mini&rsquo;s take on a washing machine:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>People have a box that cleans shirts, pants, clothes and things for feet. You put not clean things into the box through the box doors. You add water and cleaner. A round part inside the box moves the things and the water. The moving rubs bad bits from the things. The box sends the not clean water out and brings clean water in. You set how many minutes the box will work and how the box will move. At the end the box moves very fast to send water out and make the things less wet. Some boxes also have a room to dry more. The box helps save time and hard work. Many homes, apartments and stores that clean clothes have this box.
</span></span></code></pre></div><p>It does stick to the word set and it&rsquo;s nominally all correct, but it&rsquo;s a bit more stilted and much shorter.</p><p>Local models do surprisingly well for what they are. But what they are just isn&rsquo;t enough, sadly. Here&rsquo;s Qwen 3 in its quantized 8 billion parameters version - just 6 GB in VRAM with the default 4096 context length:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>A man is a person. He works, cares for family, helps others, and makes choices. He builds homes, raises children, leads, follows, joins, shares, and makes. He thinks, feels, struggles, picks, stands, fights, grows, changes, and learns. A man is a person with many jobs and things. He can be kind, strong, or smart. He may stay with others or go far. He may love, fight, or help. A man is a person who lives, works, and changes.
</span></span></code></pre></div><p>This has two violations (&ldquo;smart&rdquo; and &ldquo;choices&rdquo;). And it&rsquo;s still way better than its take on an apple, made with a 8192 context length in the hope that it would allow for better work:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>An apple is a round fruit with red or green skin. Inside, there is a core with seeds. Apples are sweet and juicy. You can eat them raw or cook them. People use apples to make pie, juice, or candy. Trees grow apples in autumn. You pick them from branches. Apples help you feel full and give energy. Some apples are small, others are big. You can find them in stores or orchards. Eating apples is healthy. They have vitamins and fiber. Apples are round and smooth. You can taste them fresh or dried. They are popular in many countries. People plant apple trees to grow more. Juice is a drink. Apples are good for snacks. They can be baked or fried. The tree has leaves and flowers in spring. Flowers turn into fruit. Apples are part of a healthy diet.
</span></span></code></pre></div><p>This has so many disallowed words it&rsquo;s barely fixable. One of them being of course &ldquo;apple&rdquo; itself - a core challenge is learning to talk about a thing without ever <em>naming</em> the thing if it&rsquo;s not part of the allowed set! I could try with say a 32k context but at that point 50% of the model&rsquo;s layers have to be loaded in RAM and processed by the CPU and then it takes a long time for any answer to come; besides, I doubt it&rsquo;d do much good against the intrinsic limitations of the model. I&rsquo;d still recommend you to try it - it&rsquo;s amazing what it can do with such a limited size. But it&rsquo;s not up to snuff for this.</p><h2 id=future-plans>Future plans?<a href=#future-plans class=hanchor arialabel=Anchor>#</a></h2><p>I will certainly keep generating; one of the first things I&rsquo;d like to do is produce meaningful explanations for every key object and action that has a word in the 1000 words set, for additional self-consistency. I&rsquo;ll look to try and support other agents and providers too, both to see how well they do and leverage more free usage allowances if they offer any. It&rsquo;s still hardly possible to generate hundreds of millions of words without paying for compute. As of now, as I said, GPT-5.1 (which does very well at the task) tends to take about 20k to 50k tokens for a single generation, depending on how hard it is, and the resulting text hardly ever hits 1k tokens of length. It would also need to be supervised because I&rsquo;ve once seen it enter into some kind of loop and use over 100k tokens on a single attempt (I asked it to explain World War 2). So for now I will hold back on the obvious idea of going through each word in the set and asking a definition for them (excluding articles, adverbs and pronouns I guess).</p><p>At some point I also want to try training models on this. I&rsquo;d like to start small, with classic old style models like n-grams, and scale up; possibly put up some artificial constraints like what&rsquo;s the best model I can make with only 100 parameters, 1,000, and so on. At some point I&rsquo;ll still need to figure out compute though because my laptop will stop being enough. I&rsquo;ll probably start moving some experiments to Google Colab and see from there.</p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h></span><hr></div><div class=pagination__buttons><a href=https://stur86.github.io/s-plus-plus/posts/first-post/ class="button inline next">[<span class=button__text>A blog is born</span>] ></a></div></div><script src=https://giscus.app/client.js data-repo=stur86/blog-giscus-comments data-repo-id=R_kgDOQawHpg data-category=Announcements data-category-id=DIC_kwDOQawHps4CyEyI data-mapping=og:title data-reactions-enabled=0 data-emit-metadata=0 data-input-position=bottom data-theme=dark data-lang=en data-loading=lazy crossorigin=anonymous async></script></article></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2025 Powered by <a href=https://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/s-plus-plus/bundle.min.js></script></div></body></html>